# PA1.2
## 概述
观察发现, watchpoint 会在每条指令的执行过程中, 将所有的Watchpoint 全部执行一遍. 
如果表达式求值效率不高, 会导致NEMU 在DEBUG 模式下的性能难以接受. 

因此, 我们采用了伪编译的方法, 将表达式转换为可以直接执行的递归函数二叉树, 
以减少watchpoint的Expr的执行开销. 

## Tokenizer
我们没有采用框架代码, 而是给予std::regex 实现了一套tokenizer 库. 
鉴于编译仅需一次, 稍微缓慢的算法是可以接受的, 因此我们将每一条规则都编译成
对象后, 对每一个新的表达式匹配所有规则以取出一个token, 如此重复直到取出所有的token

## 算符优先文法
我们支持了大量二元运算符, 并且完全按照C++的运算符优先顺序和结合性进行求值. 
|优先级| 运算符
|:-----:|:--:
|1| \|\| |
|2| &&  |
|3| \| | 
|4| & |
|5| == &nbsp;&nbsp;!= |
|6| <= &nbsp;&nbsp;>= &nbsp;&nbsp;< &nbsp;&nbsp;> |
|7| >>&nbsp;&nbsp;<< |
|8| <=&nbsp;&nbsp;>= &nbsp;&nbsp;< &nbsp;&nbsp;> |
|9| + - |
|9| * / % |
|10(unary)| * ! ~ - + |

为了实现一个完整的表达式求值, 我们采用了配合`LL(1)`递归下降文法进行

# Q&A
> 实现带有负数的表达式求值