# PA1.2
## 概述
观察发现, watchpoint 会在每条指令的执行过程中, 将所有的Watchpoint 全部执行一遍. 
如果表达式求值效率不高, 会导致NEMU 在DEBUG 模式下的性能难以接受. 

因此, 我们采用了伪编译的方法, 将表达式转换为可以直接执行的递归函数二叉树, 
以减少watchpoint的Expr的执行开销. 

## Tokenizer
我们没有采用框架代码, 而是给予std::regex 实现了一套tokenizer 库. 
鉴于编译仅需一次, 稍微缓慢的算法是可以接受的, 因此我们将每一条规则都编译成
对象后, 对每一个新的表达式尝试匹配所有规则, 以取出一个token, 如此重复直到取出所有的token

## 算符优先文法
我们支持了大量二元运算符, 并且完全按照C++的运算符优先顺序和结合性进行求值. 
以下为优先级升序排列的符号表
|优先级| 运算符||
|:-----:|:--:|---|
|1| \|\| | 
|2| &&  |
|3| \| | 
|4| & |
|5| == &nbsp;&nbsp;!= |
|6| <= &nbsp;&nbsp;>= &nbsp;&nbsp;< &nbsp;&nbsp;> |
|7| >>&nbsp;&nbsp;<< | 
|9| + - |
|9| * / % |
|10(unary)| * ! ~ - + |
为了支持如此多的运算符, 我们采用了算符优先文法作为二元运算的引擎. 

比较左右两个二元运算符的优先级, 
- 如果左边的运算符优先级更高, 应该首先执行左边的计算, 
表现在代码中就是当前节点作为右儿子合并到左边的子树上. 
- 如果右边的运算符优先级更高, 应该优先执行右边的计算, 
表现在代码中, 就是尝试解析右边符号串生成新的子树. 

## LL(1) 文法
对于单目运算符以及括号的部分, 我们采用进行LL(1)递归下降进行分析. 
编译原理教程有详细的解释, 在此不在赘述

`最后, 我们可以得到一棵表达式树, 使用tree_eval() 即可递归地完成求值操作. `


# Q&A
> 实现带有负数的表达式求值

使用LL(1) 文法即可. 
