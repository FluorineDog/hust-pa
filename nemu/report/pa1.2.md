# PA1.2
## 概述
观察发现, watchpoint 会在每条指令的执行过程中, 将所有的Watchpoint 全部执行一遍. 
如果表达式求值效率不高, 会导致NEMU 在DEBUG 模式下的性能难以接受. 

因此, 我们采用了伪编译的方法, 将表达式转换为可以直接执行的递归函数二叉树, 
以减少watchpoint的Expr的执行开销. 

## Tokenizer
我们没有采用框架代码, 而是给予std::regex 实现了一套tokenizer 库. 
鉴于编译仅需一次, 稍微缓慢的算法是可以接受的, 因此我们将每一条规则都编译成
对象后, 对每一个新的表达式匹配所有规则以取出一个token, 如此重复直到取出所有的token

## 算符优先文法
我们支持了大量二元运算符, 并且完全按照C++的运算符优先顺序和结合性进行求值. 
一下为优先级升序排列的符号表
|优先级| 运算符||
|:-----:|:--:|---|
|1| \|\| | x
|2| &&  |x
|3| \| | 
|4| & |
|5| == &nbsp;&nbsp;!= |x
|6| <= &nbsp;&nbsp;>= &nbsp;&nbsp;< &nbsp;&nbsp;> |x
|7| >>&nbsp;&nbsp;<< |
|9| + - |x
|9| * / % |xx_
|10(unary)| * ! ~ - + |x__xx
为了支持如此多的运算符, 我们

为了实现一个完整的表达式求值, 我们采用了配合`LL(1)`递归下降文法进行

# Q&A
> 实现带有负数的表达式求值